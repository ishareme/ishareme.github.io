---
title: HTTP缓存策略与增量更新总结
date: 2018-03-09 22:31:01
comments: true

tags:
    - 缓存
categories:
    - 渣技术
---

合理的利用缓存是web性能优化的必要手段，对于咱们前端来说所接触的主要缓存策略是针对客户端浏览器，客户端的缓存可以分为两种:

**1.**  利用本地存储， 比如localStorage、SessionStorage等

**2.**  利用HTTP缓存策略，其中又分为强制缓存和协商缓存

现在就来总结下HTTP缓存策略。HTTP缓存需要服务器配合，比如Apache、Ngnix等服务器软件可以为资源设置不同的HTTP缓存策略。增量更新是目前普遍采用的缓存更新方案，结合HTTP强制缓存策略，能够保证用户第一时间获取最新资源，又可以减少网络资源消耗，提高web应用程序的执行速度。

#### HTTP缓存策略
浏览器对静态资源的缓存其实本质上是HTTP协议的缓存策略，其中又可分为强制缓存策略和协商缓存策略。

**强制缓存策略：**  根据过期时间决定使用本地缓存还是请求新资源。

**协商缓存策略：**  每次都会发出请求，经过服务器对比后决定采用本地缓存还是新资源。

具体采用哪种策略是由HTTP协议的**头部**信息决定

##### 1. Expires 和 max-age #####

Expires和max-age是强制缓存策略的关键信息。

**Expires** 通过指定一个明确的时间点作为缓存资源的过期时间，在这个时间点之前将使用本地缓存的文件应答请求，不会向服务器发起实体请求(返回状态码200)
Expires的有点是可以在缓存的过期时间内减少客户端的HTTP请求，不仅节省了客户端处理时间和提高了web应用的执行速度，而且也减少了服务器负载和客户端网络资源的消耗。
```
expires:Fri, 09 Mar 2018 14:14:54 GMT
```

不过！！！Expires有一个致命的缺陷： 它所指的时间点是以服务器为准的时间，但是客户端进行过期判断的时候是将本地的时间与此时间点进行判断的。举个🌰： 如果服务器的时间是 2018年3月10日 14:14:54， 而客户端的时间是 2018年3月10日 22:14:54 ， 那么这时通过Expires控制的缓存将会失效，客户端会发起实体请求获取对应资源。（客户端动态设置时间或服务端的时间存在时间差）这显然是不合理的。

于是乎！！！在Expires之后又来了一个玩意，**Cache-control**。以便更精准的控制缓存。Cache-control的采用信息如下:

- **no-cache 和 no-store**：no-cache并非禁止缓存，而是需要先与服务端确认返回的响应是否发生变化，如果资源没有发生变化，就可以使用缓存副本而避免下载。no-store是真正意义上的禁止缓存，禁止缓存资源的返回响应。
- **public 和 private**： public不太常用，意思是响应可以被浏览器缓存器无限期的缓存，通常是使用max-age指定精准的缓存时间。 private表示响应可以被浏览器缓存，但是不予许任何中间缓存器对其缓存。(不太明白😢~~)
- **max-age**： 指定从请求的时刻开始计算，此响应的缓存副本有效的最长时间(秒)。再举个🌰： “max-age=3600”表示浏览器在接下来的1个小时内使用此响应的本地缓存，不会发送实体请求到服务器。

**max-age指定的是缓存的时间跨度，而非失效的时间点，不会受到服务器时间误差的影响。** 所以，与Expires相比起来，max-age可以更精准的控制缓存，并且**比Expires的优先级高**


![fistPost](http://oubl6fzsm.bkt.clouddn.com/http-cache.png)

##### 2. Etag 和 if-none-match #####

Etag 是服务器为资源分配的字符串形式唯一性标识。 浏览器在**cache-control指定的no-cache或者max-age和Expires均过期之后，将Etag值通过if-none-match作为请求首部信息发送给服务器**，服务器接受到请求之后，对比请求资源的Etag是否发生变化，如果未改变将返回 304 Not Modified，并且根据既定的缓存策略分配新的cache-control信息，如果资源发生改变，则会返回最新的资源以及重新分配的Etag值。


**如果强制浏览器使用协商缓存策略，需要将cache-control首部信息设置为no-cache，这样便不会判断max-age和expires过期的时间，从而每次请求资源都会经过服务器对比。**

协商缓存并非是一种比强制缓存“低级”的策略，对于一些比较特殊的应用场景或资源，协商缓存优于强制缓存。再举个🌰， 非服务端渲染的html文档，由于它是所有静态资源的引用者，所以必须保证每次请求到的资源都是最新的。同时，为了保证服务器解析和保证网站的唯一性，html文件不能包含hash指纹，在这种场景只能使用协商缓存。(使用强制缓存的话，文件的修改，由于客户端存在缓存，导致于客户端浏览的是原先的代码，不是最新修改的)



#### 覆盖更新和增量更新 ####
简单总结下覆盖更新和增量更新吧，覆盖更新和增量更新都是建立在浏览器启用强制缓存策略的前提下。

**覆盖更新:** 覆盖更新的实现方案是在引用资源的URL后面添加请求参数(比如添加请求时间搓或hash值参数)，优于存在缺陷，逐渐被淘汰。

```
//通过添加hash指纹(md5算法)
<head>
    <link rel="stylesheet" href="main.home.css?v=858d5483">
</head>
```

覆盖更新存在的缺陷: 

1. 必须保证html文件与改动的静态文件同步更新。 对于服务端渲染的项目，网站人口html和静态资源分开部署，静态资源的实现和动态资源的上线存在时间差。
2. 不利于版本回滚

**增量更新**： 实现方案是将作为参数的hash值改为作为资源文件名的一部分并删除用于更新的url参数,解决了覆盖更新的两个缺陷。

```
//通过添加hash指纹(md5算法)
<head>
    <link rel="stylesheet" href="main.home.858d5483.css">
</head>
```


#### 结语

enen~~ 对！！就这样吧，收获不少~~感恩